#!/usr/bin/env python3
"""
Report Generator for AI Practitioner Booster 2026

Generates tracker.md based on memory files and evaluation.
IMPORTANT: Tracker is a derived artifact; memory files are the source of truth.
Uses Python stdlib only - no external dependencies.

Usage:
    python report.py [--verbose] [--dry-run]
"""

import argparse
import json
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Any, Optional


# Paths
REPO_ROOT = Path(__file__).parent.parent.parent
MEMORY_DIR = REPO_ROOT / ".claude" / "memory"
PATHS_DIR = REPO_ROOT / "paths" / "Advanced"
TRACKER_PATH = PATHS_DIR / "tracker.md"


def load_json(path: Path) -> Any:
    """Load JSON file."""
    if not path.exists():
        return None
    with open(path) as f:
        return json.load(f)


def load_jsonl(path: Path) -> list:
    """Load JSON lines file."""
    if not path.exists():
        return []
    events = []
    with open(path) as f:
        for line in f:
            line = line.strip()
            if line:
                try:
                    events.append(json.loads(line))
                except json.JSONDecodeError:
                    pass
    return events


def get_evaluation() -> Optional[dict]:
    """Get the latest evaluation by running evaluate.py."""
    try:
        result = subprocess.run(
            [sys.executable, str(Path(__file__).parent / "evaluate.py")],
            capture_output=True,
            text=True,
            timeout=30
        )
        if result.returncode == 0:
            return json.loads(result.stdout)
    except Exception:
        pass
    return None


def format_score_bar(score: float, max_score: float = 10.0) -> str:
    """Format a visual score bar."""
    filled = int((score / max_score) * 10)
    empty = 10 - filled
    return f"[{'â–ˆ' * filled}{'â–‘' * empty}] {score:.1f}/{max_score:.0f}"


def format_week_status(week_num: int, status: str) -> str:
    """Format week status indicator."""
    if status == "complete":
        return f"âœ… Week {week_num}"
    elif status == "partial":
        return f"ðŸ”„ Week {week_num}"
    elif status == "current":
        return f"ðŸ“ Week {week_num} (current)"
    else:
        return f"â³ Week {week_num}"


def generate_report(evaluation: dict, profile: dict, progress: list, decisions: list) -> str:
    """Generate the tracker markdown content."""
    now = datetime.now()
    current_month = profile.get("schedule", {}).get("current_month", 1)
    current_week = profile.get("schedule", {}).get("current_week", 1)
    level = profile.get("level", "Advanced")

    # Count events by type
    week_completes = [e for e in progress if e.get("event") == "week_complete"]
    deliverables = [e for e in progress if e.get("event") == "deliverable_shipped"]

    # Build report
    lines = [
        f"# Progress Tracker â€” {level}",
        "",
        f"*Last updated: {now.strftime('%Y-%m-%d %H:%M')}*",
        "",
        "> **Note**: This file is a derived artifact generated by `report.py`. ",
        "> The source of truth is `.claude/memory/*`. Do not edit this file directly.",
        "",
        "---",
        "",
        "## Current Position",
        "",
        f"- **Level**: {level}",
        f"- **Month**: {current_month} of 12",
        f"- **Week**: {current_week} of 4",
        f"- **Overall Progress**: {((current_month - 1) * 4 + current_week) / 48 * 100:.0f}%",
        "",
        "---",
        "",
        "## Evaluation Scores",
        "",
    ]

    # Add score bars
    overall = evaluation.get("overall_score", 0)
    dimensions = evaluation.get("dimensions", {})

    lines.append(f"**Overall**: {format_score_bar(overall)}")
    lines.append("")

    for dim in ["completion", "quality", "consistency", "depth", "reflection"]:
        score = dimensions.get(dim, 0)
        lines.append(f"- {dim.capitalize()}: {format_score_bar(score)}")

    lines.extend([
        "",
        "---",
        "",
        "## Month Progress",
        "",
    ])

    # Add month progress
    for month in range(1, 13):
        if month < current_month:
            status = "âœ…"
        elif month == current_month:
            status = "ðŸ“"
        else:
            status = "â³"

        month_name = f"Month {month:02d}"
        lines.append(f"- {status} {month_name}")

    lines.extend([
        "",
        "---",
        "",
        "## Recent Activity",
        "",
    ])

    # Show recent events (last 10)
    recent_events = sorted(
        progress[-10:],
        key=lambda x: x.get("timestamp", ""),
        reverse=True
    )

    if recent_events:
        lines.append("| Date | Event | Details |")
        lines.append("|------|-------|---------|")
        for event in recent_events[:10]:
            ts = event.get("timestamp", "")[:10]
            event_type = event.get("event", "unknown")
            details = event.get("highlight", event.get("status", "-"))
            if isinstance(details, dict):
                details = str(details)
            lines.append(f"| {ts} | {event_type} | {details[:50]} |")
    else:
        lines.append("*No recent activity logged.*")

    lines.extend([
        "",
        "---",
        "",
        "## Statistics",
        "",
        f"- **Total Events Logged**: {len(progress)}",
        f"- **Weeks Completed**: {len(week_completes)}",
        f"- **Deliverables Shipped**: {len(deliverables)}",
        f"- **Decisions Made**: {len(decisions)}",
        "",
        "---",
        "",
        "## Recommendations",
        "",
    ])

    # Add recommendations
    recommendations = evaluation.get("recommendations", [])
    if recommendations:
        for rec in recommendations:
            lines.append(f"- {rec}")
    else:
        lines.append("- Keep up the good work!")

    lines.extend([
        "",
        "---",
        "",
        "## Quick Actions",
        "",
        "```",
        "/status           # Check current status",
        "/plan-week        # Plan your week",
        "/evaluate         # Compute fresh scores",
        "/adapt-path       # Get adaptation proposals",
        "```",
        "",
        "---",
        "",
        "*Generated by `.claude/path-engine/report.py`*",
    ])

    return "\n".join(lines)


def report(dry_run: bool = False, verbose: bool = False) -> dict:
    """Generate and save the tracker report."""
    # Load data
    profile = load_json(MEMORY_DIR / "learner_profile.json") or {}
    progress = load_jsonl(MEMORY_DIR / "progress_log.jsonl")
    decisions = load_jsonl(MEMORY_DIR / "decisions.jsonl")

    # Get evaluation
    evaluation = get_evaluation() or {
        "overall_score": 0,
        "dimensions": {},
        "recommendations": ["Run /evaluate to compute scores"]
    }

    if verbose:
        print(f"Loaded {len(progress)} progress events", file=sys.stderr)
        print(f"Loaded {len(decisions)} decisions", file=sys.stderr)
        print(f"Evaluation score: {evaluation.get('overall_score', 'N/A')}", file=sys.stderr)

    # Generate report content
    content = generate_report(evaluation, profile, progress, decisions)

    # Save or preview
    if dry_run:
        print(content)
        return {"status": "dry_run", "content_length": len(content)}

    # Ensure directory exists
    TRACKER_PATH.parent.mkdir(parents=True, exist_ok=True)

    # Write file
    with open(TRACKER_PATH, "w") as f:
        f.write(content)

    if verbose:
        print(f"Wrote tracker to: {TRACKER_PATH}", file=sys.stderr)

    return {
        "status": "success",
        "path": str(TRACKER_PATH),
        "content_length": len(content),
        "timestamp": datetime.utcnow().isoformat() + "Z"
    }


def main():
    parser = argparse.ArgumentParser(description="Generate progress tracker")
    parser.add_argument("--verbose", "-v", action="store_true", help="Verbose output")
    parser.add_argument("--dry-run", action="store_true", help="Print report without saving")
    args = parser.parse_args()

    result = report(dry_run=args.dry_run, verbose=args.verbose)

    if not args.dry_run:
        print(json.dumps(result, indent=2))


if __name__ == "__main__":
    main()
